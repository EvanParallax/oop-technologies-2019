In Java, all data types are separated into two groups: <b>primitive types</b> and <b>reference types.</b><div></div><div><br></div><div>Java provides only eight primitive types. They are built-in in the language syntax as keywords. The names of all primitive types are lowercase. The most commonly used type is <code>int</code> which represents an integer number.</div><div><br><div><div><div><pre><code class="language-java">int num = 100;</code></pre></div><div><br></div><div>The number of reference types is huge and constantly growing. A programmer can even create his own type and use it like standard types. The names of all reference types start with a capital letter. The most commonly used example is <code>String</code>.</div></div><h2 style="text-align: center;">The new keyword</h2><div><span>In most cases, an object of a reference type can be created using </span>the <code>new</code> keyword<span>.</span><br></div><div><br></div><div><pre><code class="language-java">String language = new String("java");
</code></pre><br></div><p>You can also use a literal for strings:</p><pre><code class="language-java">String language = "java";</code></pre><p>The first approach with the keyword new is common for reference types, while <span>the second is only string-specified. </span><span>Both approaches give us the same result for strings but they have some technical differences which we will not consider here.</span></p><h2 style="text-align: center;">The main difference</h2><p>The basic difference is that a variable of a primitive type store the actual values, whereas a variable of a reference type stores an address in memory (reference) where the data is located. The data can be presented as a complex structure that includes other data types as their parts.<br></p><p>The following picture simply demonstrates this difference. There are two main memory spaces: <b>stack</b> and <b>heap</b>. All values of primitive types are stored in stack memory, but variables of reference types store addresses on objects located in heap memory.</p><p style="text-align: center;"><span class="image-wrapper"><p style="text-align: center;"><img class="image-fullsize" height="287px" src="https://ucarecdn.com/1f65bb80-d7af-44fa-b847-9bfcc674da63/" title="Image: https://ucarecdn.com/1f65bb80-d7af-44fa-b847-9bfcc674da63/" width="399px"></p></span></p><p>We will not consider stack and heap in detail here. Just remember this difference between primitive and reference types.</p><h2 style="text-align: center;">Assignment</h2><div>The way to store data also affects the mechanism to assign the value of a variable to another variable:<br></div><div><ul><li><b>primitive types</b>: the value is just copied;<br></li><li><b>reference types</b>: the address to the value is copied (the data is shared between several variables). <br></li></ul></div><div>Here is a snippet of code and a picture that demonstrates this.</div><div><br></div><div><pre><code class="language-java">int a = 100;
int b = a; // 100 is copied to b

String language = new String("java");
String java = language;
</code></pre><br></div><div>The variable <code>b</code> has a copy of value stored in the variable <code>a</code>. But variables <code>language</code> and <code>java</code> reference to the same value, rather than copy it. The picture below clearly demonstrates the difference.</div><div><br></div><div><span class="image-wrapper"><p style="text-align: center;"><img class="image-fullsize" height="292px" src="https://ucarecdn.com/bc7d450e-5fd9-425f-8137-0fc0bc9f0303/" title="Image: https://ucarecdn.com/bc7d450e-5fd9-425f-8137-0fc0bc9f0303/" width="414px"></p></span></div><div><br></div><div>Just remember, when assigning one value of a reference variable to another, we just make the copy of a reference rather than the value itself.</div><div><br></div><h2 style="text-align: center;">Comparisons</h2><div>Comparing reference types using <code>==</code> and <code>!=</code> is not the same as comparing primitive types. Actually, when you comparing two variables of the <code>String</code> type, it compares references (addresses) rather than actual values.</div><div><br></div><div>The following code demonstrates it:<br></div><div><br></div><div></div><pre><code class="language-java">
String s1 = new String("java");

String s2 = new String("java");
String s3 = s2;

System.out.println(s1 == s2); // false
System.out.println(s2 == s3); // true
</code></pre><div><br></div><div>The picture below demonstrates this effect:<br><br></div><div><span class="image-wrapper"></span><span class="image-wrapper"><p style="text-align: center;"><img class="image-fullsize" height="299px" src="https://ucarecdn.com/0bdcd814-44e7-4f18-94a4-5605064c277c/" title="Image: https://ucarecdn.com/0bdcd814-44e7-4f18-94a4-5605064c277c/" width="349px"></p></span></div><div><br>So, you do not need use comparison operators when you want to compare the values. The correct way to compare content is to invoke the special method <code>equals</code>.<br></div><div><br></div><div><pre><code class="language-java">String s1 = new String("java");
String s2 = new String("java");
String s3 = s2;

System.out.println(s1.equals(s2)); // true
System.out.println(s2.equals(s3)); // true
</code></pre></div><div><br></div><h2 style="text-align: center;">The null object</h2></div></div><div>Unlike primitive types, a variable of a reference type can refer to a special <code>null</code> object that represents the fact that it is not initialized yet or has not a value.<br></div><div><br></div><div><pre><code class="language-java">String str = null;
System.out.println(str); // null
str = "hello";
System.out.println(str); // hello</code></pre></div><div><br>Unfortunately, the frequent use of this value can easily lead to errors in the program and complicate the code. <span>Try to </span>avoid <code>null</code> whenever<span> it is possible, but use it if you really need.</span></div>