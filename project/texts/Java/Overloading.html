<h2 style="text-align: center;"><b></b>Methods overloading</h2><p>If methods have the same name, but a different number or type of parameters, they are <b>overloaded</b>. It means you can invoke different methods by the same name by passing different arguments.<br></p><p>As an example, let's consider some overloaded method from the standard class <code class="java">Math</code>:</p><pre><code class="language-java">public static int abs(int a) { return (a &lt; 0) ? -a : a; }

public static float abs(float a) { return (a &lt;= 0.0F) ? 0.0F - a : a; }</code></pre><p>These methods have the same name but different type of the argument. They are overloaded.<br></p><p><b>Important note: </b>it's impossible to declare more than one method with the same name and parameters (number and types), even with different return types. The return type is not considered for overloading because it's not a part of the signature.</p><p>Here are three methods <code class="java">print</code> for printing different values.</p><pre><code class="language-java">public static void print(String stringToPrint) {
    System.out.println(stringToPrint);
}

public static void print(String stringToPrint, int times) {
    for (int i = 0; i &lt; times; i++) {
        System.out.println(stringToPrint);
    }
}

public static void print(int val) {
    System.out.println(val);
}</code></pre><p>The first method prints an input string, the second one prints an input string a given number of times and the last one prints an integer value. These methods are overloaded.</p><p>Let's invoke these methods:</p><pre><code class="language-java">print("some string");
print("another string", 2);
print(5);</code></pre><p>As you can see, it's possible to call any of these methods by the same name passing suitable arguments. The code outputs:</p><pre><code class="language-java">some string
another string
another string
5
</code></pre><p>The overloading mechanism allows us not to write different names for methods that perform the similar operations.</p><p>Looking ahead, we note that overloading is a form of the static (compile-time) polymorphism.</p><h2 style="text-align: center;"><b></b>Overloading and casting</h2><p>In the case, where the type of a method parameter is not exactly the same as the type of the passed argument, the compiler chooses the method that has the closest type of the argument in order of the implicit casting.</p><p>Let's see an example.</p><pre><code class="language-java">public class OverloadingExample {

    public static void print(short a) {
        System.out.println("short arg: " + a);
    }

    public static void print(int a) {
        System.out.println("int arg: " + a);
    }

    public static void print(long a) {
        System.out.println("long arg: " + a);
    }

    public static void print(double a) {
        System.out.println("double arg: " + a);
    }

    public static void main(String[] args) {
        print(100);
    }
}</code></pre><p>Let's call <code class="java">print(100)</code>, the program outputs:</p><pre><code class="language-java">int arg: 100</code></pre><p>Let's remove or comment the method <code class="java">public static void print(int a)</code>, then recompile and run the program again.<b></b></p><p>The result is:</p><pre><code class="language-java">long arg: 100</code></pre><p>Ok, now, let's remove the method <code class="java">public static void print(long a)</code> too. After recompiling the program outputs:</p><pre><code class="language-java">double arg: 100.0</code></pre><p>If we remove the method <code class="java">public static void print(double a)</code> the program can't be compiled.</p><p>In this way, the compiler chooses the most suitable method in the order of implicit casting. If it's impossible we must cast an argument explicitly like in the following example:</p><pre><code class="language-java"> public class OverloadingExample {

    public static void print(short a) {
        System.out.println("short arg: " + a);
    }

    public static void main(String[] args) {
        print((short) 100);  // explicit casting 
    }
}</code></pre> 